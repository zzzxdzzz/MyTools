;+
; NAME:
;
;  photmods.pro
;
; PURPOSE:
;
;  Fit photometric models.
;
; CATEGORY:
;
;  OVIRS photometric processing
;
; CALLING SEQUENCE:
;
;  photmods[, infile][, outfile][. plotfile][, configuration=conf][, model=model][, /quiet][, /help][, /manual]
;
; INPUTS:
;
;
; OPTIONAL INPUTS:
;
;  infile     - A string to specify the input PDIF file.
;  outfile    - A string to specify the output FITS file to save the best-fit
;               parameters
;  plotfile   - A string to specify the folder to output PS file from plot_ps.pro
;
; KEYWORD PARAMETERS:
;
;  configuration - A string of the name of configuration file.  Default is
;               'photmods.conf' in the same directory as this program file.
;               If configuration file not found, program will generate an
;               error.
;  model      - A string to specify what model to fit.  This keyword will
;               override the specifications in the configuration file.  The
;               options are 'lommel-seeliger', 'rolo', 'minnaert', mcewen'
;               (case insensitive).  If the specified model is not recognized,
;               then program will generate an error.
;  quiet      - Quiet mode
;  verbose    - Verbose model to print out all information generated by all
;               subroutines such as I/F data binning, validation, and fitting,
;               everything.  This mode can only be turned on by this keyword.
;  help       - Display usage help
;  manual     - Display software manual
;
; OUTPUTS:
;
;  None
;
; OPTIONAL OUTPUTS:
;
;
;
; COMMON BLOCKS:
;
;
;
; SIDE EFFECTS:
;
;
;
; RESTRICTIONS:
;
;
; PROCEDURE USED:
;
;  findpro.pro, which in turn uses 'fdecomp.pro' both in Goddard IDL
;  Astronomy User's Library (http://idlastro.gsfc.nasa.gov)
;  mpfit.pro, v1.84
;  read_pdif.pro, mpfit_phomodel.pro, phot_model.pro, write_phomodel.pro,
;  plot_ps.pro
;
; EXAMPLE:
;
;
;
; MODIFICATION HISTORY:
;
;  v1.0 : May 28, 2016, created by JYL @PSI
;  v1.1 : July 1, 2016, modified by JYL @PSI
;    Changed API to make all parameters optional for the program.  All
;    parameters can now be configured through configuration file,
;    'photmods.conf' by default.
;  v1.2 : July 12, 2016, modified by XDZ @PSI
;    * Add overwrite parameter in configuration file, overwrite the output
;      when overwrite = yes
;    * Corrected a bug can cause configuration file couldn't be found in linux
;      system.
;    * Add plotfile as an optianal input
;    * Add Windows/Linux support when output .PS files
;  v1.3 : July 15, 2016, modified by JYL @PSI
;    * Corrected a bug that caused the output photometric parameter files to
;      only save the parameters from the last model fit of a series of model
;      fits when overwrite=yes
;    * Use benchmark.pro to simplify the code for benchmark.
;  v1.4 : July 17, 2016, modified by XDZ @PSI
;    * Add plotfile parameter to command line of photmods function
;  v1.5 : July 20, 2016, modified by JYL @PSI
;    * Added propagation of a few configuration parameters to output file
;    * Changed the call to read_pdif.pro to read_spec.pro
;    * Corrected a bug that caused the `sis' parameter from configuration file
;      not functioning
;    * Some optimization
;  v1.6 : Dec 19, 2016, modified by XDZ @PSI
;    * Delete data pre-selection conditions related to spatial_resolution
;    * Transpose ioferr to make it the same dimension as iof
;    * Fix a bug when ioferr=0
;    * Changed info.incidence, info.emission, info.phase to same as read_spec.pro
;  v1.7 : Jan 4, 2017, modified by JYL @PSI
;    * Optimize data checking, and modularize this step to subroutine
;      `check_phodata.pro'
;  v1.8 : Jan 12, 2017, modified by JYL @PSI
;    * Change file name and routine name to small case
;    * Fix a bug that prints out wavelengths when verbose=no
;  v1.9 : March 6, 2017, modified by JYL @PSI
;    * Update for the revised API of write_phomodel.pro
;  v1.9.1 : March 16, 2017, JYL@PSI
;    * String out quality data saving to write_phomodel_qua.pro
;    * Removed call to modfits.pro
;  March 27, 2017, JYL @PSI
;    Use system variable !quiet and `message` to control info message
;    Change keyword `verbose` to `quiet`
;  March 28, 2017, JYL @PSI
;    Add keyword `status` for simple error handling
;  March 29, 2017, JYL @PSI
;    Add traceback info to error handler printout
;  April 7, 2017, JYL @PSI
;    Use `print` rather than `message` to print out info messages
;  June 28, 2017, XDZ @PSI
;    Read both parameter and p - covariance matrix from mpfit, save to outfile
;-

; define filled circle symbol
PRO filled_circle_symbol
    aa=findgen(40)/39.*!pi*2. ; set plots' symbols
    usersym,.5*cos(aa),.5*sin(aa),/fill ; set the size of the data points
END


PRO photmods, infile, outfile, plotfile, configuration=conf, model=model, quiet=quiet, help=hp, manual=man, status=status, benchmark=bench, verbose=verbose, _extra=ex

    version = '3.0'
    intvrsnb = '20180206'  ; internal version number


    ; print short usage info
    IF keyword_set(hp) THEN BEGIN
        msg = ["Usage: photmods[, 'inputfile'][, 'outputfile'][, 'plotfile']",$
               "                [, model=['model1', 'model2', ...]",$
               "                [, configuration='photmods.conf'][, /quiet]",$
               "Or:    photmods, /manual"]
        FOR i=0, n_elements(msg)-1 DO message,/info,/noname,msg[i]
        status = 1
        RETURN
    ENDIF

    ; display manual
    findpro, 'photmods', /noprint, dirlist=d
    d = d[0]
    IF keyword_set(man) THEN BEGIN
        xdisplayfile, d+'manual.txt'
        status = 2
        RETURN
    ENDIF

    ; establish error handler
    catch, error_code
    IF error_code NE 0 THEN BEGIN
        help, /last_message, output=str
        FOR i=0, n_elements(str)-1 DO message, /info, /noname, /noprefix, str[i]
        status = -1
        RETURN
    ENDIF

    ; load configuration
    IF NOT keyword_set(conf) THEN conf = d+'photmods.conf'
    IF ~file_test(conf) THEN message, 'configuration file '+conf+' not found'
    input = {}
    IF n_params() GE 1 THEN input = create_struct(input, 'infile', infile)
    IF n_params() GE 2 THEN input = create_struct(input, 'outfile', outfile)
    IF n_params() EQ 3 THEN input = create_struct(input, 'plotfile', plotfile)
    IF keyword_set(model) THEN input = create_struct(input, 'model', model)
    IF n_elements(quiet) NE 0 THEN input = create_struct(input, 'quiet', quiet)
    IF keyword_set(bench) THEN input = create_struct(input, 'benchmark', bench)
    IF NOT keyword_set(verbose) THEN verbose=0
    IF NOT keyword_set(conf) THEN conf = d+'photmods.conf'
    IF ~file_test(conf) THEN message, 'configuration file '+conf+' not found'
    con = load_conf(conf, input=input)
    plt = con.plot
    plotfile = con.plotfile

    ; print out information
    IF ~con.quiet THEN BEGIN
        print
        print, systime()
        print, 'photmods '+version
        print, 'Input file: '+con.infile
        print, 'Output file: '+con.outfile
        print, 'Model configuration file: '+conf
        print
        print, 'Date of configuration file: '+con.date
        print, 'Generated by: '+con.name
        print
        print, 'Modles to fit: '+strjoin(con.model, ', ')
        print, 'Data selection criteria:'
        print, '    I/F data range: ('+strjoin([string(con.iofmin),string(con.iofmax)],', ')+')'
        print, '    Phase angle range: ('+strjoin([string(con.phamin),string(con.phamax)],', ')+')'
        print, '    Incidence angle range: ('+strjoin([string(con.incmin),string(con.incmax)],', ')+')'
        print, '    Emission angle range: ('+strjoin([string(con.emimin),string(con.emimax)],', ')+')'
        print, '    Resolution range: ('+strjoin([string(con.resmin),string(con.resmax)],', ')+')'
        print, '    FOV Fill: '+string(con.fovfill)
        print
        print, 'Make plot: '+ (con.plot ? 'Yes' : 'No')
        IF con.plot THEN print, '    Plot file name root: '+con.plotfile
        print
    ENDIF

    ;IF ~con.quiet THEN BEGIN
    ;    s = ''
    ;    read, 'Proceed? (Y|N): ', s
    ;    IF strcmp(s, 'y', 1, /fold_case) EQ 0 THEN RETURN
    ;ENDIF

    ; benchmark
    IF con.benchmark THEN t0 = systime(1)

    ; load user symbol
    IF plt THEN BEGIN
        filled_circle_symbol
    ENDIF

    ; load data
    data = read_spec(con.infile, error=error, wav=wav, info=info, header=header, quiet=con.quiet)
    tmp = size(data, /dim)
    nwv = tmp[0]
    ; propagate values of some keywords to output
    prop = {}
    keys = ['obsstart', 'obsend', 'sclkstrt', 'sclkend', 'pxbnfil']
    FOR i=0, n_elements(keys)-1 DO prop = create_struct(prop, keys[i], sxpar(header, keys[i]))
    keys = ['iofmin', 'iofmax', 'incmin', 'incmax', 'emimin', 'emimax', 'phamin', 'phamax', 'resmin', 'resmax', 'fovfill', 'polysmth']
    con_tags = strlowcase(tag_names(con))
    FOR i=0, n_elements(keys)-1 DO prop = create_struct(prop, keys[i], con.(where(con_tags EQ keys[i])))
    prop = create_struct(prop, 'spdif', file_basename(con.infile))
    prop = create_struct(prop, 'pmodsft', 'photmods.pro')
    prop = create_struct(prop, 'pmodver', version)
    prop = create_struct(prop, 'idl_ver', !version.release)
    prop = create_struct(prop, 'os_name', !version.os_name)
    prop = create_struct(prop, 'sysarch', !version.arch)
    prop = create_struct(prop, 'intvrsnb', intvrsnb)

    IF con.benchmark THEN t1 = benchmark(t0, 'Load PDIF data')

    ; models to be fitted
    IF keyword_set(model) THEN models_tofit=[model] ELSE models_tofit=con.model
    ; bin data in scattering parameter space
    IF con.phobin THEN BEGIN
        IF ~con.quiet THEN print, 'binning photometric data'
        bin_phodata, data, info.phaseang, info.incidang, info.emissang, iofb, phab, incb, emib, errb, phares=con.phabin, incres=con.incbin, emires=con.emibin, quiet=~verbose
    ENDIF ELSE BEGIN
        iofb = data
        phab = info.phaseang
        incb = info.incidang
        emib = info.emissang
        errb = error
    ENDELSE

    ; loop through models
    models = ['lommel-seeliger', 'rolo', 'minnaert', 'mcewen', 'akimov']
    FOR i=0, n_elements(models)-1 DO BEGIN

        IF (i EQ 0) AND con.overwrite THEN overwrite = 1 ELSE overwrite = 0
        IF strcmp(models[i], 'lommel-seeliger', 5, /fold_case) EQ 1 THEN np=4 $
        ELSE IF strcmp(models[i], 'rolo', 5, /fold_case) EQ 1 THEN np=7 $
        ELSE IF strcmp(models[i], 'minnaert', 5, /fold_case) EQ 1 THEN np=6 $
        ELSE IF strcmp(models[i], 'mcewen', 5, /fold_case) EQ 1 THEN np=7 $
        ELSE IF strcmp(models[i], 'akimov', 5, /fold_case) EQ 1 THEN np=4

        ; if not specified to be fitted, then skip this model and save dummy
        ; data in output
        IF total(strmatch(models_tofit,models[i],/fold_case)) LT 0.5 THEN BEGIN
            par = fltarr(nwv,np)
            covar = fltarr(nwv,np,np)
            chisq = fltarr(nwv)
            write_phomodel, models[i], par, covar, wav, chisq, con.outfile, prop=prop, sis=con.sis, overwrite=overwrite, quiet=con.quiet
            continue
        ENDIF

        IF ~con.quiet THEN print, 'fitting model: '+models[i]
        ; prepare for plot
        IF plt THEN BEGIN
            fdecomp, plotfile, disk, path, name
            path = path + models[i]
            IF file_test(path) EQ 0 THEN file_mkdir, path
            slash = !version.os_family EQ 'Windows' ? '\' : '/'
            pltfile = path+slash+name+'_'+models[i]
        ENDIF

        ; data pre-selection based on geometry
        geom = (incb GT con.incmin) AND $
               (incb LT con.incmax) AND $
               (emib GT con.emimin) AND $
               (emib LT con.emimax) AND $
               (phab GT con.phamin) AND $
               (phab LT con.phamax)

        par = []
        covar = []
        ; loop through wavelength
        allstatus = []
        FOR k=0, nwv-1 DO BEGIN
            ; data selection with iof data value
            iof = iofb[k,*]
            ;IF ~con.quiet THEN print, 'wave = '+string(wav[k])
            in = where(geom AND (iof GT con.iofmin) AND (iof LT con.iofmax))
            dstatus = -255
            IF in[0] NE -1 THEN BEGIN
                iof = iof[in]
                ioferr = (errb[k,in])[*]
                pha = phab[in]
                inc = incb[in]
                emi = emib[in]
                ; check the validity of data
                dstatus = check_phodata(iof, pha, inc, emi, ioferr=ioferr, quiet=~verbose)
            ENDIF
            allstatus = [allstatus, dstatus]
            IF dstatus GE 0 THEN BEGIN
                ; fit model
                p_covar = mpfit_phomodel(models[i], iof, pha, inc, emi, ioferr=ioferr, quiet=~verbose)
                p = p_covar[*,0]
                cov = p_covar[*,1:*]
                cov = reform(cov,1,np,np)
            ENDIF ELSE BEGIN
                ; skip this band and fill parameters with 0s
                p = fltarr(np)
                cov = fltarr(1,np,np)
            ENDELSE
            par = [par, transpose(p)]
            covar = [covar,cov]
        ENDFOR

        ; smooth photometric parameters if so specified
        par0 = par
        IF con.polysmth GT 0 THEN par = polysmooth_phopar(par, x=wav, degree=con.polysmth)

        ; generate plot and model quality assessment
        chisq = []
        corr = []
        FOR k=0, nwv-1 DO BEGIN
            IF allstatus[k] GE 0 THEN BEGIN
                ; calculate modeled
                iof = iofb[k,*]
                in = where(geom AND (iof GT con.iofmin) AND (iof LT con.iofmax))
                iof = iof[in]
                ioferr = (errb[k,in])[*]
                pha = phab[in]
                inc = incb[in]
                emi = emib[in]
                dstatus = check_phodata(iof, pha, inc, emi, ioferr=ioferr, /quiet)
                iofmod = phot_model(models[i], pha, inc, emi, par[k,*], /radf)
                ; make plot
                IF plt THEN plot_ps, pltfile, models[i], par[k,*], iof, iofmod, pha, inc, emi, con, wav=wav[k]
                ; calculate quality assessment
                c = total(((iofmod-iof)/ioferr)^2)
                ratio = iof/iofmod
                slp1 = (linfit(iof, iofmod))[1]
                cc1 = correlate(iof, iofmod)
                slp2 = (linfit(pha, ratio))[1]
                cc2 = correlate(ratio, pha)
                slp3 = (linfit(inc, ratio))[1]
                cc3 = correlate(ratio, inc)
                slp4 = (linfit(emi, ratio))[1]
                cc4 = correlate(ratio, emi)
                cc = [slp1, cc1, slp2, cc2, slp3, cc3, slp4, cc4]
            ENDIF ELSE BEGIN
                c = 0.
                cc = replicate(0., 8)
            ENDELSE
            chisq = [chisq, c]
            corr = [corr, transpose(cc)]
        ENDFOR

        ; write best-fit parameters with parameters error to output file
        write_phomodel, models[i], par, covar, wav, chisq, con.outfile, prop=prop, sis=con.sis, overwrite=overwrite, quiet=con.quiet

        ; save quality assessment quantities
        qfile = strmid(con.outfile, 0, strpos(con.outfile, '.fits'))+'_qua.fits'
        write_phomodel_qua, models[i], corr, wav, qfile, overwrite=overwrite, quiet=con.quiet

        IF con.benchmark THEN BEGIN
            t2 = benchmark(t1, 'Fitting '+models[i]+' model')
            t1 = t2
        ENDIF
    ENDFOR

    ; set MNBEST keyword
    hdr = headfits(con.outfile, exten=0, silent=~verbose)
    fxaddpar, hdr, 'MNBEST', best_model(qfile)
    modfits, con.outfile, 0, hdr, exten_no=0

    ; quality plot
    IF plt THEN Plot_model_quality, qfile

    ; print final benchmark
    IF con.benchmark THEN t3 = benchmark(t0, 'All tasks')

    status = 0

END
